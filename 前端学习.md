# 自我介绍

我是富楠，是浙江工商大学电子信息专业的一名大四学生，在本科期间，我总共参与开发了3个项目，其中包括一项互联网+创业项目。
在这些项目中我都有负责过前端开发、后端php、java的开发和独自全栈开发，项目服务端架构基本采用传统的LAMP架构。前端框架的话，我用的比较多的也比较熟悉的时Vue和微信小程序框架。

# 项目

## 简介

## 亮点

## 难点

# JavaScript

## 数据类型

1.基本数据类型（值类型）：字符串（String）、数字（Number）、布尔（Boolean）、空（Null）、未定义（Undefined）、Symbol（全局唯一的值）。
2.引用数据类型：对象（Object）、数组（Array）、函数（Function）。
3.在内存中怎么存储：栈内存，堆内存。
	基本数据类型：栈内存；
	引用数据类型：栈内存存放地址指向堆内存。
4.`typeof`返回值`undefined`，`string`，`number`，`object`，`boolean`，`function`
	`typeof`在判断`null`、`array`、`object`以及函数实例（new+函数）时，得到的都是`object`
	instance（实例），`instanceof`判断该对象时谁的实例。这里涉及到了对象的继承，它的判断就是根据原型链进行搜寻，在对象 obj1 的原型链上若存在另一个对象 obj2 的原型属性，那么 `（obj1 instanceof obj2）` 返回 true。

## 函数

函数：在特定环境中执行代码的对象

**`getter`** & **`setter`**

**`get`**语法将对象属性绑定到查询该属性时将被调用的函数。

```js
const obj = {
  log: ['a', 'b', 'c'],
  get latest() {
    if (this.log.length === 0) {
      return undefined;
    }
    return this.log[this.log.length - 1];
  }
};
console.log(obj.latest);
// expected output: "c"

// 要随时将 getter 添加到现有对象，使用 Object.defineProperty().
var o = { a:0 }
Object.defineProperty(o, "b", { get: function () { return this.a + 1; } });
```

当尝试设置属性时，**`set`**语法将对象属性绑定到要调用的函数。

```js
const language = {
  set current(name) {
    this.log.push(name);
  },
  log: []
};
language.current = 'EN';
language.current = 'FA';
console.log(language.log);
// expected output: Array ["EN", "FA"]
// 请注意，current属性是未定义的，访问它时将会返回 undefined。
```

只需使用 `delete`，就可删除 getter & setter：`delete obj.latest`

## 原型

`__proto__、 prototype`、`constructor`

`prototype`：每个**函数**都有一个 prototype 属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。

```js
function Person() {}
// prototype是函数才会有的属性
Person.prototype.name = 'Kevin';
var person1 = new Person();
var person2 = new Person();
console.log(person1.name) // Kevin
console.log(person2.name) // Kevin
```

`__proto__`：每一个JavaScript**引用对象**(null除外)都具有的一个属性，叫**proto**，这个属性会指向该对象的原型。

```js
function Person() {}
var person = new Person();
console.log(person.__proto__ === Person.prototype); // true
```

constructor：每个原型都有一个 constructor 属性指向关联的构造函数。

```tsx
function Person() {}
console.log(Person === Person.prototype.constructor); // true
```

```jsx
function Person() {}
var person = new Person();
console.log(person.__proto__ == Person.prototype) // true
console.log(Person.prototype.constructor == Person) // true
// 顺便学习一个ES5的方法,可以获得对象的原型
console.log(Object.getPrototypeOf(person) === Person.prototype) // true
```

<img src="C:\Users\FuNan\AppData\Roaming\Typora\typora-user-images\image-20210114211838942.png" alt="image-20210114211838942" style="zoom: 67%;" />

高级补充

```js
Function.__proto__===Function.prototype
Function.prototype===Function.prototype
Object.__proto__===Function.prototype
```

```js
Function.prototype.a = 'a';
Object.prototype.b = 'b';
function Person(){};
var p = new Person();
console.log(p.a); //undefined
console.log(p.b); //b
```

```js
typeof(Function.prototype) //Function
typeof(Object.prototype) //Object
typeof(Person.prototype) //Object
```

`isPrototypeOf()`：`a.isPrototypeOf(b)`判断a是否是b的原型
`getPrototypeOf()`：`Object.getPrototypeOf(b)`：得到b的原型
`hasOwnProperty()`：检测一个属性是存在于实例中，还是存在于原型中

## Promise

Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。
Promise 对象代表一个异步操作，有三种状态：`pending`（未完成）、`fullfilled`（完成）、`rejected`（失败）

```jsx
var promise = new Promise(function(resolve, reject){
    // ... some code
    if (/* 异步操作成功 */) {
        resolve(value);
    } else {
        reject(error);
    }
})
```

在过去，做多重的异步操作，会导致经典的回调地狱，
因为 `Promise.prototype.then` 和 `Promise.prototype.catch` 方法返回的是 promise， 所以它们可以被**链式调用**。
我们把回调绑定到被返回的 Promise 上代替以往的做法，形成一个 Promise 链

```js
//链式调用
function firstThing(res, rej){
    res("firstThing done!")
}
function secondThing(res, rej){
    res("secondThind done!")
}
function thirdThing(res, rej){
    res("thirdThing done!")
}

new Promise(firstThing).then((e) => {
    console.log(e)
    return new Promise(secondThing)
}).then((e) => {
    console.log(e)
    return new Promise(thirdThing)
}).then((e) => {
    console.log(e)
}).catch(fail)
```

**`Promise.all`**可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回**最先**被reject失败状态的值。`Promise.all`获得的成功结果的数组里面的数据顺序和`Promise.all`接收到的数组顺序是一致的

```jsx
//promise.all
let p1 = new Promise((resolve, reject) => {
  resolve('process1 done!')
})
let p2 = new Promise((resolve, reject) => {
  resolve('process2 done!')
})
let p3 = Promise.reject('process3 fail!')

Promise.all([p1, p2]).then((result) => {
  console.log(result)     //['process1 done!', 'process2 done!']
}).catch((error) => {
  console.log(error)	
})

Promise.all([p1,p3,p2]).then((result) => {
  console.log(result)
}).catch((error) => {
  console.log(error)      // 'process3 fail!'
})
```

```js
// 手写
function promiseAll(promises) {
    return new Promise(function (resolve, reject) {
        if (!Array.isArray(promises)) {
            return reject(new TypeError('arguments must be an array'));
        }
        var resolvedCounter = 0;
        var promiseNum = promises.length;
        var resolvedValues = new Array(promiseNum);
        for (var i = 0; i < promiseNum; i++) {
            (function (i) {
                Promise.resolve(promises[i]).then(function (value) {
                    resolvedCounter++
                    resolvedValues[i] = value
                    if (resolvedCounter == promiseNum) {
                        return resolve(resolvedValues)
                    }
                }, function (reason) {
                    return reject(reason)
                })
            })(i)
        }
    })
}
```

**`Promise.race`** `Promise.race([p1, p2, p3])`里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。

```jsx
let p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('success')
  },1000)
})
let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('failed')
  }, 500)
})

Promise.race([p1, p2]).then((result) => {
  console.log(result)
}).catch((error) => {
  console.log(error)  // 打开的是 'failed'
})
```

```js
// 手写
function promiseRace(promises) {
    if (!Array.isArray(promises)) {
        throw new Error("promises must be an array")
    }
    return new Promise(function (resolve, reject) {
        promises.forEach(p =>
            Promise.resolve(p).then(data => {
                resolve(data)
            }, err => {
                reject(err)
            })
        )
    })
}
```

## async & await

为什么要用await：为了使我们的异步代码，更像同步的代码。

`async` 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 `return` 一个直接量，`async` 会把这个直接量通过 `Promise.resolve()` 封装成 Promise 对象。

```js
async function testAsync() {
    return "hello async";
}

const result = testAsync();   // Promise {<fulfilled>: "hello async"}
console.log(result);   // undefined
```

`async` 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样

```js
testAsync().then(e => {
    console.log(e);   // "hello async"
});
```

在没有 `await` 的情况下执行 `async` 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。

如果`await`等到的是一个 Promise 对象，`await` 就忙起来了，它会**阻塞**后面的代码，等着 `Promise` 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。这就是 await 必须用在 `async` 函数中的原因。`async` 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。

```js
// 使用 async await
var process = new Promise((r, j) => {
    setTimeout(() => {
        r(1000)
    }, 3000)
})
async function useAsync() {
	var result = await process
    console.log(result)
}
useAsync()
```

```js
// 使用promise
var process = new Promise((r, j) => {
    setTimeout(() => {
        r(1000)
    }, 3000)
})
process().then(e => {
    console.log(e);
});
```

`async/await` 的优势在于处理 then 链。

## es6新特性

#### **箭头函数**

一般箭头函数都只有一个表达式作为函数主题：

```javascript
const greet = name => `Hello ${name}!`;
```

这种函数表达式形式称为**简写主体语法**。
但是如果箭头函数的主体内需要多行代码, 则需要使用**常规主体语法**：

- 它将函数主体放在花括号内
- 需要使用 return 语句来返回内容。

```javascript
const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map( name => {
  name = name.toUpperCase();
  return `${name} has ${name.length} characters in their name`;
});
```

箭头函数没有自己的`this`，`arguments`，`super`或`new.target`。更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数，没有`prototype`属性。箭头函数的this永远指向调用者的父类的上下文,任何方法都改变不了指向,比如 `call()` , `apply()` , `bind()`。

#### **var、let、 const**

均有函数作用域
`var`：无块级作用域，变量提升。
`let`：有块级作用域。全局声明时不会被作为`window`的属性（而`var`可以）
`const`：有块级作用域，必须初始化，不能修改（常量）。常量的含义指对象不可修改但可以改变对象内部的属性（不能修改的是栈内存在的值和地址）。

```js
const app = {
    id:1,
    name:"lhs"
}
app.name="ljq";
console.log(app.name);//输出：ljq
```

#### **模板字符串**

用倒引号 `( `` )`（而不是单引号 `( '' )` 或双引号`( "" )`）表示，可以包含用 `${expression}` 表示的占位符

```javascript
let message = `${student.name} please see ${teacher.name} in ${teacher.room} to pick up your report card.`;
```

#### **解构赋值**

```js
// 数组解构
const point = [10, 25, -34]
const [x, y, z] = point
// 对象解构
const gemstone = {type: 'quartz',color: 'rose',karat: 21.29}
const {type, color, karat} = gemstone
```

#### **`for...of`循环**

它结合了其兄弟循环形式 `for` 循环和 `for...in` 循环的优势，可以循环任何可迭代（也就是遵守可迭代协议）类型的数据。默认情况下，包含以下数据类型：`String`、`Array`、`Map` 和 `Set`，注意不包含 `Object` 数据类型（即 `{}`）。**默认情况下，对象不可迭代**。

#### **展开运算符**

能够将字面量对象展开为多个元素。

```javascript
const books = ["Don Quixote", "The Hobbit", "Alice in Wonderland", "Tale of Two Cities"]
console.log(...books)
// 使用展开运算符结合数组
const fruits = ["apples", "bananas", "pears"]
const vegetables = ["corn", "potatoes", "carrots"]
const produce = [...fruits,...vegetables]
console.log(produce)
```

```javascript
// 剩余参数
function sum(...nums) { // sum(1,2,3)
  console.log(...nums) // 1,2,3
  console.log(nums) // [1,2,3]
}
const order = [20.17, 18.67, 1.50, "cheese", "eggs", "milk", "bread"];
const [total, subtotal, tax, ...items] = order;
console.log(total, subtotal, tax, items);
```

#### **字面量增强**

```js
// 属性增强写法
const id = 1;
const name = "LHS";
const age = 20
const app = {
    id,
    name,
    age,
    // 函数增强写法
    msg(){
        console.log("函数增强写法");
    }
}
console.log(app);
```

## 面向对象

对象：无序属性的集合

### 创建对象

#### 工厂模式

抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节。
解决了创建多个相似对象的问题，但没有解决对象识别的**问题**（即怎样知道一个对象的类型）

```js
function createPerson(name, age) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.sayName = function() {
		console.log(this.name)
    }
    return o;
}
var you = createPerson(...)
```

#### 构造函数模式

构造函数与普通函数的唯一区别就在于调用他们的方式不同。使用构造函数的**主要问题**，就是每个方法都在在每个实例上重新创建一遍（两个实例的同一个方法不是用一个`Function`的实例），可以通过转移函数定义到构造函数外部来解决（缺点：函数丧失全局意义，自定义构造函数丧失封装性）。
创建自定义构造函数意味着将来可以将他的实例表示为一种特定的类型，这正是胜过工厂模式的地方。

```js
function Person(name) {
    this.name = name;
    this.getName = function () {
        console.log(this.name);
    };
    this.setName = function (name) {
        this.name = name;
    };
}
```

#### 原型模式

`prototype`就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。

```js
function Person() {}
Person.prototype.name="funan";
Person.prototype.age=23;
Person.prototype.sayName=function() {
    console.log(this.name)
}
// 更简单的原型语法
Person.prototype = {
    name: "funan",
    age: 23,
    sayName: function() {
        console.log(this.name)
    }
}
```

在上面的代码中，更简单的语法将`Person.protptype`设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外：`constructor`属性不再指向`Person`了。每创建一个函数，就会同时创建他的`prototype`对象，这个对象会自动获得`constructor`属性，而这里使用的语法，本质上完全重写了默认的`prototype`对象，因此`constructor`属性也就变成了新对象的`constructor`属性（指向`Object`构造函数），不再指向`Person`函数。尽管`instanceof`操作符能返回正确的结果。

```js
var you = new Person();
you instanceof Object; // true
you instanceof Person; // true
you.constructor == Person; // false
you.constructor == Object; // true
// 可以像下面这样修改回适当的值
Person.prototype = {
    constructor: Person.
    // ...
}
// 注意，以这种方式重设constructor属性会导致它的[[Enumerable]]特性设置为true
```

原型的动态性：对原型对象所做的任何修改都能够立即从实例上反映出来。尽管可以随时为原型添加属性和方法，但如果重写整个原型对象，那情况就不一样了，把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系。实例中的指针仅指向原型，而不指向构造函数。

```js
function Person(){}
var you = new Person();
Person.prototype = {
    name: "your name",
    sayName: function() {console.log(this.name)}
}
you.sayName(); // error
```

原型模式的**主要问题**：共享，包含引用类型值的原型属性会被所有实例共享。解决方法：组合使用构造函数模式和原型模式。

```js
function Person(){}
Person.prototype = {
    name: "your name",
    friends: ["your friends1", "your friends2"]
}
var you = new Person()
var her = new Person()
you.name="real name"
you.friends.push("your friends3")
console.log(you.friends===her.friends) // true
console.log(you.name===her.name) // false
```

#### 动态原型模式

把所有信息都封装在了构造函数中，而通过在**构造函数中初始化原型**（仅在必要情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化。

```js
function Person(name, age) {
    this.name = name;
    this.age = age;
    // 方法
    if(typeof this.sayName != "function") {
        Person.prototype.sayName = function() {
            console.log(this.name)
        }
    }
}
```

#### 寄生构造函数模式

这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象，从表面上看，这个函数很想构造函数。

```js
function Person(name, age){
	var o = new Object();
	o.name = name;
	o.age = age;
    o.sayName = function(){
        console.log(this.name)
    }
    return o
}
var you = new Person("your name", 23)
```

这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用此模式

```js
function myArray() {
    var val = new Array();
    val.push.apply(val, arguments);
    val.toPipedString = function() {
        return this.join("|");
    };
    return val;
}
var colors = new myArray("red", "blue", "green")
```

#### 稳妥构造函数模式

**稳妥对象**：所谓稳妥对象，指的是没有公共属性，而且其方法也不引用`this`对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用`this`和`new`），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是创建对象的实例方法不引用`this`，二是不使用`new`操作符调用构造函数。

```js
function Person(name, age){
	var o = new Object();
	o.name = name;
	o.age = age;
    o.sayName = function(){
        console.log(name)
    }
    return o
}
var you = Person("your name", 23)
you.sayName()
```

es6中的`class`语法糖

```js
class Person {
    constructor(name){
        this.name = name;
    }
    getName(){
        console.log(this.name);
    }
    setName(name){
        this.name = name;
    }
}
```

### 继承

#### 原型链

将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。假如让原型对象等于另一个类型的实例，此时的原型对象将包含另一个指向另一个原型的指针，相应的，另一个原型中也包含者一个指向另一个构造函数的指针。如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。

实现原型链有一种基本模式，代码大致如下。

```js
function Father() {
    this.property = true;
}
Father.prototype.getFatherValue = function() {
    return this.property;
}
function Son() {
    this.sonproperty = false;
}
// 继承了Father
Son.prototype = new Father();

Son.prototype.geSonValue = function() {
    return this.sonproperty;
}

var instance = new Son();
console.log(instance.getFatherValue()); // true
```

在上面的代码中，没有使用`Son`提供的默认原型，而是给他换了一个新的原型；这个原型就是`Father`的实例，于是，新原型不仅具有作为一个`Father`实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了`Father`的原型。最终结果就是`instance`指向`Son`的原型，具有`Father`实例的方法和属性，同时又指向`Father`的原型，`getFaterValue()`方法仍在`Father.prototype`中，但`property`则位于`Son.prototype`中。此外，要注意`instance.constructor`现在指向的是`Father`，因为`Son`的原型指向另一个原型，这个原型的`constructor`指向`Father`。

通过原型链实现继承时，不能使用对象字面量创建原型方法，这样做会**重写**原型链。

#### 借用构造函数

借用构造函数技术来解决原型中包含**引用类型值的问题**，即在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用`apply()`和`call()`方法也可以在新创建的对象上执行构造函数。

```js
function Father() {
    this.numbers = [1, 2, 3]
}
function Son() {
    // 继承了Father
    Father.call(this)
}
var instance1 = new Son()
var instance2 = new Son()
instance1.numbers.push(4)
console.log(instance1.numbers) // [1, 2, 3, 4]
console.log(instance2.numbers) // [1, 2, 3]
```

相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数**传递参数**。`Father.call(this, params)`。

借用构造函数的**问题**：函数无法复用（方法都在构造函数中定义）、所有类型都只能使用构造函数模式。

#### 组合继承

组合继承，有时候也叫做伪经典继承，指的是将原型链和借用构造函数技术组合。借用构造函数实现实例属性的继承，使用原型链实现原型属性和方法的继承。

```js
function Father(name) {
	this.name=name;
	this.numbers=[1,2,3];
}
Father.prototype.sayName=function(){
    console.log(this.name);
}
function Son(name, age) {
    // 继承属性
    Father.call(this,name);
    this.age=age;
}
// 继承方法
Son.prototype = new Father();  // 缺点：调用两次父类构造函数
Son.prototype.constructor = Son;
// ...
```

#### 原型式继承

这种方法没有严格意义上的构造函数，借助原型可以基于已有的对象创建对象，同时还不必因此创建自定义类型。

```js
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
} // 本质上讲，Object()对传入其中的对象进行了一次浅拷贝
```

`es5`通过新增`Object.create()`方法规范化了原型式继承。这个方法接受两个参数，一个用作新对象原型的对象和一个为新对象定义额外属性的对象。

```js
var person = {
    name: "funan",
    friends: ["you", "him", "her"]
}
var anotherPerson = Object.create(person, {
    name: "it"
})
console.log(anotherPerson.name) // "it"
```

#### 寄生式继承

寄生式继承是与原型式继承紧密相关的一种思路，与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数。

```js
function create(original){
    var clone = Object(original); // 通过调用函数创建一个对象
    clone.sayHi = function(){ // 以某种方式增强这个对象
        console.log("hi");
    }
    return clone; // 返回这个对象
}
```

#### 寄生组合式继承

组合继承时`JavaScript`最常用的继承模式，它最大的问题就是无论什么情况下都会调用两次超类型构造函数：一次在子类型构造函数内部，另一次在创建子类型原型的时候。所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需的无非就是超类型原型的一个副本而已。本质上，就是**使用寄生式继承来继承超类型的原型**，然后再将结果指定给子类型的原型。

```js
function inheritPrototype(son, father) {
    var prototype = Object(father.prototype); // 创建超类型副本
    prototype.constructor = son; // 弥补重写原型而失去默认的constructor
    son.prototype = prototype; // 副本赋予子类型的原型
}
function Father(name) {
    this.name = name;
    this.numbers = [1,2,3];
}
Father.prototype.sayName = function() {
    console.log(this.name);
}
function Son(name, age) {
    Father.call(this, name);
    this.age = age;
}
inheritPrototype(Son, Father);
Son.prototype.sayAge = function() {
    console.log(this.age)
}
```

## 手写 new

`new`共经历了4个步骤
1、创建一个新对象
2、将构造函数的作用域赋给新对象
3、执行构造函数
4、返回新对象

1、创建一个空对象

```js
var obj = Object.create(null)
```

2、设置原型链（当构造函数构建一个实例后，该实例将包含一个指针（隐式属性），指向构造函数的原型对象）

```js
Object.setPrototypeOf(obj, func.prototye)
```

3、让`func`中的`this`指向`obj`，并执行`func`的函数体。（创建新的对象之后，将构造函数的作用域赋给新对象（因此`this`就指向了这个新对象））

```
var res = func.call(obj, params)
```

4、判断`func`返回值类型，如果是引用类型则返回这个引用类型对象（`result`），否则返回`obj`

```js
return res instanceof Object ? res : obj
```

## **call apply bind**

```js
var age = 17
var obj = {
    name: 'fn',
    age: this.age, // 17
    talk: function(a, b) {console.log(this.name, this.age, a, b)}
}
var obj2 = {
    name: 'fn2',
    age: '23',
}
obj.talk.call(obj2, 1, 2) // fn2 23 1 2
obj.talk.apply(obj2, [1,2]) // fn2 23 1 2
obj.talk.bind(obj2, 1, 2)() // fn2 23 1 2
obj.talk.bind(obj2, [1,2])() // fn2 23 [1,2] undefined
```

## this指向

在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值：

- 如果是该函数是一个构造函数，this指针指向一个新的对象
- 在严格模式下的函数调用下，this指向undefined
- 如果是该函数是一个对象的方法，则它的this指针指向这个对象
- 等等...

`This`被证明是令人厌烦的面向对象风格的编程。

```js
function Person() {
  // Person() 构造函数定义 `this`作为它自己的实例.
  this.age = 0;
  setInterval(function growUp() {
    // 在非严格模式, growUp()函数定义 `this`作为全局对象,
    // 与在 Person()构造函数中定义的 `this`并不相同.
    this.age++;
  }, 1000);
}
var p = new Person();

在ECMAScript 3/5中，通过将this值分配给封闭的变量，可以解决this问题。

function Person() {
  var that = this;
  that.age = 0;
  setInterval(function growUp() {
    // 回调引用的是`that`变量, 其值是预期的对象.
    that.age++;
  }, 1000);
}

箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同：

function Person(){
  this.age = 0;
  setInterval(() => {
    this.age++; // |this| 正确地指向 p 实例
  }, 1000);
}
```

## 闭包

指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

## 垃圾回收机制

**引用**：垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 JavaScript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

### 引用计数垃圾收集

这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

```js
var o = {
  a: {
    b:2
  }
};
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集
var o2 = o; // o2变量是第二个对“这个对象”的引用
o = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有
var oa = o2.a; // 引用“这个对象”的a属性
               // 现在，“这个对象”有两个引用了，一个是o2，一个是oa
o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
           // 但是它的属性a的对象还在被oa引用，所以还不能回收
oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
```

**限制：循环引用**：该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

```js
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o
  return "azerty";
}
f();
```

### 标记-清除算法

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在 JavaScript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。
**限制**: 那些无法从根对象查询到的对象都将被清除尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。

## 浅拷贝 & 深拷贝

```js
// 浅拷贝 JSON.parse(JSON.stringify(Obj))对于正则表达式类型、函数类型等无法进行深拷贝。
function copy(obj){
    var newobj = {};
    for ( var attr in obj) {
        newobj[attr] = obj[attr];
    }
    return newobj;
}

// 递归深拷贝
function deepCopy(obj){
    if(!(obj instanceof Object) || obj instanceof Function){
        return obj;
    }
    var newobj = obj instanceof Array ? [] : {};
    for (attr in obj) {
        newobj[attr] = deepCopy(obj[attr]);
    }
    return newobj;
}
```

## 事件

### **事件流**

**事件冒泡**：时间开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。
**事件捕获**：事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件，事件捕获的用意在于时间到达预订目标之前就捕获他。
**DOM事件流**：“DOM2级事件”规定事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。

### **currentTarget & target**

`Target`：触发事件bai的元素。
`CurrentTarget`：事件绑定的元素
事件处理函数中的**`this`**指向为`currentTarget`

### **事件委托**

对"事件处理程序过多"问题的解决方案就是事件委托。利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如`click`事件会一直冒泡到`document`层次，我们可以为整个页面指定一个`onclick`事件处理程序，而不必给每个可单击的元素分别添加事件。

```js
var list = document.getElementById("myLinks");
EventUtil.addHandler(list, "click", function(event) {
    event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);
    switch(target.id){
            // ...
    }
})
```

## eventLoop

**宏任务**： 一些异步任务的回调会依次进入宏队列，等待后续被调用，这些异步任务包括：`script`、`setTimeout`、`setInterval`、`requestAnimationFrame`、`I/O`、UI交互事件
**微任务**：另一些异步任务的回调会依次进入微队列，等待后续被调用，这些异步任务包括：`Promise`、`Object.observe`、`MutationObserver`

​	JavaScript代码执行流程
​	1、执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如`setTimeout`等）；
​	2、全局Script代码执行完毕后，执行栈会清空；
​	3、从微任务队列中取出位于队首的回调任务，放入执行栈中执行；
​	4、继续取出位于队首的任务，放入执行栈中执行，以此类推，直到直到把微任务队列中的所有任务都执行完毕。注意，如果在执行微任务的过程中，又产生了微任务，那么会加入到队列的末尾，也会在这个周期被调用执行；
​	5、微任务队列中的所有任务都执行完毕，此时微任务队列为空，执行栈也为空；
​	6、取出宏任务队列中位于队首的任务，放入执行栈中执行（宏任务队列一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务）；
​	7、执行完毕后，执行栈为空；
​	8、重复第3-7个步骤；

```js
console.log(1);
setTimeout(() => {
  console.log(2);
  Promise.resolve().then(() => {
    console.log(3)
  });
});
new Promise((resolve, reject) => {
  console.log(4)
  resolve(5)
}).then((data) => {
  console.log(data);
  Promise.resolve().then(() => {
    console.log(6)
  }).then(() => {
    console.log(7)
    setTimeout(() => {
      console.log(8)
    }, 0);
  });
})
setTimeout(() => {
  console.log(9);
})
console.log(10); // 正确答案 1 4 10 5 6 7 2 3 9 8

Promise.resolve().then(() => {
  console.log(1);
  Promise.resolve().then(() => {
    console.log(2);
  }).then(() => {
    console.log(3);
  });
}).then(() => {
  console.log(4);
}); // 1 2 4 3
```

## 防抖 & 节流

**函数防抖（`debounce`）**：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。

```js
// 防抖
function debounce(fn, wait) {    
    var timeout = null;    
    return function() {        
        clearTimeout(timeout);        
        timeout = setTimeout(fn, wait);    
    }
}
```

**函数节流（`throttle`）**：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。函数节流主要有两种实现方法：时间戳和定时器。

```js
// 定时器
var throttle = function(func, delay) {            
    var timer = null;            
    return function() {   
        if (!timer) {
            timer = setTimeout(function() {                        
                func();                      
                timer = null;                    
            }, delay);   
        }
    }
}
```

## 跨域

### `cors`

`cors`跨域资源共享策略。**Access-Control-Allow-Origin**

### `jsonp`

`JSONP` 是 `JSON with Padding`的简称，浏览器对于`script`，`iframe`等标签的`src`等属性是没有同源策略限制的，我们通过动态插入`script`标签的方式，利用script标签的`src`属性发起请求。`jsonp`的方式兼容性非常好，即便是那些老古董浏览器，也可以用`jsonp`的方式解决跨域问题，但是它也有所限制，它只能使用get方式发起请求，并且对于不同域之间页面的`js`互相调用无能为力。

```js
function showJsonp(obj){
  console.log(obj.message);
}
var url = 'http://127.0.0.1:8787/?func=showJsonp'
var script = document.createElement('script');
script.setAttribute('src',url);
script.setAttribute('type','text/javascript');
document.getElementsByTagName('head')[0].appendChild(script);
```

`document.domain`

因为浏览器是通过`document.domain`属性来检查两个页面是否同源，因此只要通过设置相同的`document.domain`，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）

## 数据结构

### 排序

```js
function quickSort(arr, l, r){
    if(l<r){
        var i = l,j = r;
        var x = arr[l];
        while(i<j){
            while(i < j && arr[j] >= x){j--;}
            if(i<j){
                arr[i]=arr[j];
                i++;
            }
            while(i < j && arr[i] < x){i++}  
            if(i<j) 
            {
                arr[j] = arr[i];
                j--;
            }
        }
        arr[i]=x;
        quickSort(arr,l,i-1);
        quickSort(arr,i+1,r);
    }
}
```

### sort底层

### 实现数组的map方法

### map、weakMap

ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

实例的属性和操作方法:
（1）size 
（2）set(key, value)
（3）get(key)
（4）has(key)
（5）delete(key)
（6）clear()

Map 结构原生提供三个遍历器生成函数和一个遍历方法。
keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历 Map 的所有成员。
Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。

WeakMap结构与Map结构类似，也是用于生成键值对的集合。
WeakMap与Map的区别有两点。首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。WeakMap 不支持迭代以及 keys()，values() 和 entries() 方法。所以没有办法获取 WeakMap 的所有键或值。

### 数组展平

```js
// 普通方法
function flat(arr){
    var result=[]
    function flatten(arr){
        for (var i = 0; i < arr.length; i++) {
            if (Array.isArray(arr[i])) {
                flatten(arr[i]);
            }else{
                result.push(arr[i]);
            }        
        }
    }
    flatten(arr);
    return result;
}
// concat
function flatten(arr) {
    return arr.reduce((plane, toBeFlatten) => (plane.concat(Array.isArray(toBeFlatten) ? flatten(toBeFlatten) : toBeFlatten)), []);
}
// 展开符
function flatten(arr) {
    flatten = (arr) => [].concat(...arr);
    return flatten(arr.map(x=>Array.isArray(x)? deepFlatten(x): x));
}
// Array.falt(Infinity)
```

### 数组去重

```js
// Set
var arr = new Set(originArray)
// 两层循环
// indexOf
```

### Map和普通对象区别

### for in 与for of

## JavaScript方法

### 数组

**`flat`**：数组展平，`arrayObject.flat(n)`，参数为n，表示要拉平n层的嵌套数组，n为`Infinity`时展成一层。
**`concat`**：连接两个或多个数组，`arrayObject.concat(array1, array2, ..., arrayN)`。
**`every & some`**：`arrayObject.every((e)=>typeof(e)==='number')`判断数组中 [ every：每个，some：有 ] 元素是否符合条件。
**`filter`**：`arrayObject.filter((e)=>e instanceof Array || e instanceof Object)`返回数组中符合条件的元素。
**`find & findindex`**：`arrayObject.find((e)=>e>10)`返回符合条件的第一个元素 & 元素索引位置。
**`forEach`**：`arrayObject.forEach((item, index)=>console.log(index, ':', item))`获取数组每个元素。
**`includes`**：`arrayObjec.includes(3,3)`是否包含指定值。该方法的第二个参数表示搜索的起始位置，默认为 0 。如果第二个参数为负数，则表示倒数的位置。
**`indexOf`**：`arrayObject.indexOf(searchvalue,fromindex)`查找数组元素的索引位置。
**`join`**：`arrayObject.join(separator)`数组中的所有元素放入一个字符串，separator可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。
**`shift & unshift & pop & push`**：`shift`删除并返回第一个元素，`pop`删除并返回最后一个元素，`push/shift`向数组的末尾 / 开头添加一个或多个元素，并返回新的长度。
**`reduce`**：接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。`arrayObject.reduce((sum, num)=>a-b)`
**`slice`**：`arrayObject.slice(start,end)`，从已有的数组中返回选定的元素。
**`sort`**：`arryObject.sort((a,b)=>{return a-b})`升序。
**`toString 、reverse`**

### 字符串

**`split`**`：stringObject.split(separator,howmany)`用于把一个字符串分割成字符串数组。`separator`指定分割点，`howmany`指定返回数组最大长度。
**`replace`**：`stringObject.replace(regexp/substr,replacement)`。
**`slice`**：`stringObject.slice(start,end)`，提取字符串的片断。
**`substr`**：`stringObject.substr(start,length)`，在字符串中抽取从 *start* 下标开始的指定数目的字符。
**`toUpperCase`**：用于把字符串转换为大写。
**`trim 、 trimEnd 、 trimStart`**：去除空格。
**`search`**
**`match`**

### 对象

## AJAX

## 词法作用域和动态作用域

1、词法作用域，函数的作用域在函数定义的时候就决定了（取决于函数定义的位置）
2、动态作用域，函数的作用域在函数调用的时候就决定了（取决于函数的调用）

## 正则

`RegExp`：是正则表达式（regular expression）的简写。

```js
// 语法
var reg = new RegExp(reg,modifiers) // 修饰符(modifiers)描述了检索是否是全局，区分大小写等。
// 简写
var reg = /reg/modifiers
// test()
reg.test(...) // true or false
// exec()
var reg = new RegExp("e");
console.log(reg.exec("The best things in life are free")) // e
```

修饰符(modifiers)用于执行不区分大小写和全文的搜索。

| 修饰符                                             | 描述                                                     |
| :------------------------------------------------- | :------------------------------------------------------- |
| [i](https://www.runoob.com/js/jsref-regexp-i.html) | 执行对大小写不敏感的匹配。                               |
| [g](https://www.runoob.com/js/jsref-regexp-g.html) | 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 |
| m                                                  | 执行多行匹配。                                           |

| 表达式                                                       | 描述                               |
| :----------------------------------------------------------- | :--------------------------------- |
| [[abc\]](https://www.runoob.com/jsref/jsref-regexp-charset.html) | 查找方括号之间的任何字符。         |
| [[^abc\]](https://www.runoob.com/jsref/jsref-regexp-charset-not.html) | 查找任何不在方括号之间的字符。     |
| [0-9]                                                        | 查找任何从 0 至 9 的数字。         |
| [a-z]                                                        | 查找任何从小写 a 到小写 z 的字符。 |
| [A-Z]                                                        | 查找任何从大写 A 到大写 Z 的字符。 |
| [A-z]                                                        | 查找任何从大写 A 到小写 z 的字符。 |
| [adgk]                                                       | 查找给定集合内的任何字符。         |
| [^adgk]                                                      | 查找给定集合外的任何字符。         |
| (red\|blue\|green)                                           | 查找任何指定的选项。               |

| 元字符                                                       | 描述                                        |
| :----------------------------------------------------------- | :------------------------------------------ |
| [.](https://www.runoob.com/jsref/jsref-regexp-dot.html)      | 查找单个字符，除了换行和行结束符。          |
| [\w](https://www.runoob.com/jsref/jsref-regexp-wordchar.html) | 查找数字、字母及下划线。                    |
| [\W](https://www.runoob.com/jsref/jsref-regexp-wordchar-non.html) | 查找非单词字符。                            |
| [\d](https://www.runoob.com/jsref/jsref-regexp-digit.html)   | 查找数字。                                  |
| [\D](https://www.runoob.com/jsref/jsref-regexp-digit-non.html) | 查找非数字字符。                            |
| [\s](https://www.runoob.com/jsref/jsref-regexp-whitespace.html) | 查找空白字符。                              |
| [\S](https://www.runoob.com/jsref/jsref-regexp-whitespace-non.html) | 查找非空白字符。                            |
| [\b](https://www.runoob.com/jsref/jsref-regexp-begin.html)   | 匹配单词边界。                              |
| [\B](https://www.runoob.com/jsref/jsref-regexp-begin-not.html) | 匹配非单词边界。                            |
| \0                                                           | 查找 NULL 字符。                            |
| [\n](https://www.runoob.com/jsref/jsref-regexp-newline.html) | 查找换行符。                                |
| \f                                                           | 查找换页符。                                |
| \r                                                           | 查找回车符。                                |
| \t                                                           | 查找制表符。                                |
| \v                                                           | 查找垂直制表符。                            |
| [\xxx](https://www.runoob.com/jsref/jsref-regexp-octal.html) | 查找以八进制数 xxx 规定的字符。             |
| [\xdd](https://www.runoob.com/jsref/jsref-regexp-hex.html)   | 查找以十六进制数 dd 规定的字符。            |
| [\uxxxx](https://www.runoob.com/jsref/jsref-regexp-unicode-hex.html) | 查找以十六进制数 xxxx 规定的 Unicode 字符。 |

| 量词                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [n+](https://www.runoob.com/jsref/jsref-regexp-onemore.html) | 匹配任何包含至少一个 n 的字符串。例如，/a+/ 匹配 "candy" 中的 "a"，"caaaaaaandy" 中所有的 "a"。 |
| [n*](https://www.runoob.com/jsref/jsref-regexp-zeromore.html) | 匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 "A ghost booooed" 中的 "boooo"，"A bird warbled" 中的 "b"，但是不匹配 "A goat grunted"。 |
| [n?](https://www.runoob.com/jsref/jsref-regexp-zeroone.html) | 匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 "angel" 中的 "el"，"angle" 中的 "le"。 |
| [n{X}](https://www.runoob.com/jsref/jsref-regexp-nx.html)    | 匹配包含 X 个 n 的序列的字符串。例如，/a{2}/ 不匹配 "candy," 中的 "a"，但是匹配 "caandy," 中的两个 "a"，且匹配 "caaandy." 中的前两个 "a"。 |
| [n{X,}](https://www.runoob.com/jsref/jsref-regexp-nxcomma.html) | X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a{2,}/ 不匹配 "candy" 中的 "a"，但是匹配 "caandy" 和 "caaaaaaandy." 中所有的 "a"。 |
| [n{X,Y}](https://www.runoob.com/jsref/jsref-regexp-nxy.html) | X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，/a{1,3}/ 不匹配 "cndy"，匹配 "candy," 中的 "a"，"caandy," 中的两个 "a"，匹配 "caaaaaaandy" 中的前面三个 "a"。注意，当匹配 "caaaaaaandy" 时，即使原始字符串拥有更多的 "a"，匹配项也是 "aaa"。 |
| [n$](https://www.runoob.com/jsref/jsref-regexp-ndollar.html) | 匹配任何结尾为 n 的字符串。                                  |
| [^n](https://www.runoob.com/jsref/jsref-regexp-ncaret.html)  | 匹配任何开头为 n 的字符串。                                  |
| [?=n](https://www.runoob.com/jsref/jsref-regexp-nfollow.html) | 匹配任何其后紧接指定字符串 n 的字符串。                      |
| [?!n](https://www.runoob.com/jsref/jsref-regexp-nfollow-not.html) | 匹配任何其后没有紧接指定字符串 n 的字符串。                  |

**RegExp 对象方法**

| 方法     | 描述                                               |
| :------- | :------------------------------------------------- |
| compile  | 在 1.5 版本中已废弃。 编译正则表达式。             |
| exec     | 检索字符串中指定的值。返回找到的值，并确定其位置。 |
| test     | 检索字符串中指定的值。返回 true 或 false。         |
| toString | 返回正则表达式的字符串。                           |

**支持正则表达式的 String 对象的方法**

| 方法    | 描述                             | FF   | IE   |
| :------ | :------------------------------- | :--- | :--- |
| search  | 检索与正则表达式相匹配的值。     | 1    | 4    |
| match   | 找到一个或多个正则表达式的匹配。 | 1    | 4    |
| replace | 替换与正则表达式匹配的子串。     | 1    | 4    |
| split   | 把字符串分割为字符串数组。       | 1    | 4    |

## http请求

请求方法：get, post、head、options、put、patch、delete、trace和 connect方法。
区别：

常见的媒体格式类型如下：

- text/html ： HTML格式
- text/plain ：纯文本格式
- text/xml ： XML格式
- image/gif ：gif图片格式
- image/jpeg ：jpg图片格式
- image/png：png图片格式

以application开头的媒体格式类型：

- application/xhtml+xml ：XHTML格式
- application/xml： XML数据格式
- application/atom+xml ：Atom XML聚合格式
- application/json： JSON数据格式
- application/pdf：pdf格式
- application/msword ： Word文档格式
- application/octet-stream ： 二进制流数据（如常见的文件下载）
- application/x-www-form-urlencoded ： <form encType="">中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

# Vue2.0 & Vue3.0

## 生命周期

生命周期钩子的 `this` 上下文指向调用它的 `Vue` 实例。
`beforeCreate & created`
`beforeMounted & mounted`
`beforeUpdate & updated`
`beforeDestroy & destroyed`
`active`

vue3
`onBeforeMount`
`onMounted`
`onBeforeUpdate`
`onUpdated`
`onBeforeUnmount`
`onUnmounted`
`onActivated`
`onDeactivated`
`onErrorCaptured`

## vue2/3双向数据绑定的原理

### vue2

数据劫持 结合 发布订阅模式，其核心是 `Object.defineProperty()`方法。`Object.defineProperty(obj, prop, descriptor)` ，这个语法内有三个参数，分别为 obj （要定义其上属性的对象） prop （要定义或修改的属性）descriptor（具体的改变方法）。

```js
var obj = {}
Object.defineProperty(obj, 'test', {
	get: function(){
        // ...
    },
    set: function(){
        // ...
    }
})
```

我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：
1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

### vue3

- 用跟踪 (track) 函数修改值
- 用触发 (trigger) 函数更新为最新的值

当把一个普通的 JavaScript 对象作为 `data` 选项传给应用或组件实例的时候，Vue 会使用带有 getter 和 setter 的处理程序遍历其所有 property 并将其转换为 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)。这是 ES6 仅有的特性，但是我们在 Vue 3 版本也使用了 `Object.defineProperty` 来支持 IE 浏览器。两者具有相同的 Surface API，但是 Proxy 版本更精简，同时提升了性能。

**Proxy 是一个包含另一个对象或函数并允许你对其进行拦截的对象。**

```js
const p = new Proxy(target, handler)
```

`target`：要使用 `Proxy` 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。
`handler`：一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 `p` 的行为。

```js
const handler = {
    get: function(obj, prop) {
        return prop in obj ? obj[prop] : 37;
    }
};
const p = new Proxy({}, handler);
p.a = 1;
p.b = undefined;
console.log(p.a, p.b);      // 1, undefined
console.log('c' in p, p.c); // false, 37
```

Observer、Watcher、Dep、Compile

## 计算属性 & 侦听属性

```js
computed: {
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
}
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
```

可以通过this改变吗：不能

```js
watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
}
```

## 事件处理

### 事件修饰符

在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。为了解决这个问题，Vue.js 为 `v-on` 提供了**事件修饰符**。之前提过，修饰符是由点开头的指令后缀来表示的。

```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>

<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a>

<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```

### 按键修饰符

在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符：

```html
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">
```

## 自定义指令

一个指令定义对象可以提供如下几个钩子函数 (均为可选)：

- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。

- `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。
- `unbind`：只调用一次，指令与元素解绑时调用。

接下来我们来看一下钩子函数的参数 (即 `el`、`binding`、`vnode` 和 `oldVnode`)。

指令钩子函数会被传入以下参数：

- `el`：指令所绑定的元素，可以用来直接操作 DOM。

- binding

  ：一个对象，包含以下 property：

  - `name`：指令名，不包括 `v-` 前缀。
  - `value`：指令的绑定值，例如：`v-my-directive="1 + 1"` 中，绑定值为 `2`。
  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。
  - `expression`：字符串形式的指令表达式。例如 `v-my-directive="1 + 1"` 中，表达式为 `"1 + 1"`。
  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `"foo"`。
  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。

- `vnode`：Vue 编译生成的虚拟节点。移步 [VNode API](https://cn.vuejs.org/v2/api/#VNode-接口) 来了解更多详情。

- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。

```html
<div id="hook-arguments-example" v-demo:foo.a.b="message"></div>
```

```js
Vue.directive('demo', {
  bind: function (el, binding, vnode) {
    var s = JSON.stringify
    el.innerHTML =
      'name: '       + s(binding.name) + '<br>' +
      'value: '      + s(binding.value) + '<br>' +
      'expression: ' + s(binding.expression) + '<br>' +
      'argument: '   + s(binding.arg) + '<br>' +
      'modifiers: '  + s(binding.modifiers) + '<br>' +
      'vnode keys: ' + Object.keys(vnode).join(', ')
  }
})

new Vue({
  el: '#hook-arguments-example',
  data: {
    message: 'hello!'
  }
})
// 局部注册
directives: {
    focus2: {
        inserted: function(el){
            el.focus();
        }
    }
}
```

## 异步更新队列

可能你还没有注意到，Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 `Promise.then`、`MutationObserver` 和 `setImmediate`，如果执行环境不支持，则会采用 `setTimeout(fn, 0)` 代替。

例如，当你设置 `vm.someData = 'new value'`，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 `Vue.nextTick(callback)`。这样回调函数将在 DOM 更新完成后被调用。例如：

##  vuex实现原理

4个属性

如何判断是否commit，vuex模块如何实现

## vue-router

## 虚拟DOM

## diff

# HTML

## 重绘和重排

优化

# CSS

## 选择器

箭头`>`：子一代所有
加号`+`：紧接的兄弟元素
[attribute]：标签带 attribute 的元素；[target=-blank]选择所有使用target="-blank"的元素；[title~=flower]选择标题属性包含单词"flower"的所有元素，[lang|=en]选择 lang 属性以 en 为开头的所有元素
波浪`~`：p~ul 选中p之后的每一个兄弟ul元素
a[xxx^="https"]，a[xxx$=".pdf"]，a[xxx*="runoob"]：选中每一个xxx属性的值以“https” （开头）/ “.pdf” （结尾）/ “runoob”（包含子字符串）的元素
:not(xxx)
:empty：选择每个没有任何子级的p元素（包括文本节点）

## 伪类 & 伪元素

**伪类**
active：用鼠标点击时，元素增加特效，鼠标松开时，特效消失
focus：聚焦
hover：悬浮
link：链接未点击
visited：链接点击
xxx-child

**伪元素**
before、after：在元素之前或之后插入某些内容
first-letter、first-line：首字母、首行

## flex

flex-grow：默认0不扩展
flex-shrink：默认1，空间不足收缩
flex-basis：基准宽度

## 居中
子元素宽高不确定，实现居中布局

## 盒模型

## flex属性

## position属性

## 清除浮动

## animation、transform、raf

性能优化

## visibility:hidden & display:none

display不占据空间，visibility会
display不继承，visibility会继承
display有回流，visibility无
display不会计数，visibility会

## em & rem

对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素。**

**em**

- 子元素字体大小的em是相对于父元素字体大小
- 元素的width/height/padding/margin用em的话是相对于该元素的font-size

```css
<div>
    我是父元素div
    <p>
        我是子元素p
        <span>我是孙元素span</span>
    </p>
</div>
```

```css
div {
  font-size: 40px;
  width: 10em; /* 400px */
  height: 10em;
  border: solid 1px black;
}
p {
  font-size: 0.5em; /* 20px */ 
  width: 10em; /* 200px */
  height: 10em;
  border: solid 1px red;
}
span {
  font-size: 0.5em;  
  width: 10em;
  height: 10em;
  border: solid 1px blue;
  display: block;
}
```

**rem**

rem是全部的长度都相对于根元素，根元素是谁？<html>元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。

```css
html {
    font-size: 10px;
    }
div {
    font-size: 4rem; /* 40px */
    width: 30rem;  /* 300px */
    height: 30rem;
    border: solid 1px black;
}
p {
    font-size: 2rem; /* 20px */
    width: 15rem;
    height: 15rem;
    border: solid 1px red;
}
span {
    font-size: 1.5rem;
    width: 10rem;
    height: 10rem;
    border: solid 1px blue;
    display: block;
} 
```

## CSS元素样式优先级

id > 伪类 & 属性 & class > 标签 > 关系 & 通配

## CSS 画形状

### 三角形

```css
div {
    width: 0;
    border: 40px solid;
    border-color: transparent transparent green;
}
```

### 圆形

```css
div {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    background: green
}
```

## BFC

BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。

- ### BFC的特性

  1、属于同一个BFC的两个相邻容器的上下margin会重叠（重点）
  2、计算BFC高度时浮动元素也参于计算（重点）
  3、BFC的区域不会与浮动容器发生重叠（重点）
  4、BFC内的容器在垂直方向依次排列
  5、元素的margin-left与其包含块的border-left相接触
  6、BFC是独立容器，容器内部元素不会影响容器外部元素

只要元素满足下面任一条件即可触发 BFC 特性：

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)

作用：
避免margin重叠、自适应两栏布局、清除浮动

# 浏览器

## 存储机制

## 重绘回流

# GIT

# 计算机网络

## HTTP缓存策略

## 从url请求一直到呈现出请求后的网页的过程

1、域名解析
2、TCP连接
3、HTTP请求
4、服务器处理HTTP请求
5、浏览器页面渲染
6、断开TCP连接

## get和post

## 域名和IP地址是怎么相互映射

## 七 / 五层结构

**`osi`七层模型**
**应用层**：为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等
**表示层**：用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别
**会话层**：负责建立、管理和终止表示层实体之间的通信会话
**传输层**：为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”
**网络层**：过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础
**数据链路层**：将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测
**物理层**：实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流

**TCP / IP五层协议**
**应用层**：Telnet、FTP、e-mail等
**传输层**：TCP和UDP
**网络层**：IP、ICMP、IGMP
**数据链路层**：设备驱动程序及接口卡
**物理层**

## tcp的三次握手

**第一次握手**
客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。
**第二次握手**
服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。
**第三次握手**
客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

**为什么三次**

第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
第三次握手：客户端发包，服务端收到了。
这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
因此，需要三次握手才能确认双方的接收与发送能力是否正常。

## tcp的四次挥手

第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。

**为什么四次**

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

## http状态码

## 缓存头

## 常用的网络协议

## xss

# 操作系统

## 进程和线程，进程间通信，线程间通信

# 设计模式

# 幂等

# 代码

## 原型

function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
};
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
};

Foo.getName(); 
getName(); 
Foo().getName(); 
getName(); 
new Foo.getName();
new Foo().getName();
new new Foo().getName(); 

## this指向

![image-20210114182257664](C:\Users\FuNan\AppData\Roaming\Typora\typora-user-images\image-20210114182257664.png)

## 事件轮询机制

![image-20210114182323346](C:\Users\FuNan\AppData\Roaming\Typora\typora-user-images\image-20210114182323346.png)

## promiss.all

![image-20210114182420947](C:\Users\FuNan\AppData\Roaming\Typora\typora-user-images\image-20210114182420947.png)

## 实现数组的slice方法：

![image-20210114182546022](C:\Users\FuNan\AppData\Roaming\Typora\typora-user-images\image-20210114182546022.png)

## 判断数据类型3种方法，实现instaneOf

![image-20210114182620025](C:\Users\FuNan\AppData\Roaming\Typora\typora-user-images\image-20210114182620025.png)
